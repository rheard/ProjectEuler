"""
If we are presented with the first k terms of a sequence it is impossible to say with
    certainty the value of the next term, as there are infinitely many polynomial functions
    that can model the sequence.

As an example, let us consider the sequence of cube numbers.
    This is defined by the generating function, 
u_n = n**3: 1, 8, 27, 64, 125, 216, ...

Suppose we were only given the first two terms of this sequence. Working on the principle that
    "simple is best" we should assume a linear relationship and predict the next term to be 15
    (common difference 7). Even if we were presented with the first three terms,
    by the same principle of simplicity, a quadratic relationship should be assumed.

We shall define OP(k, n) to be the nth term of the optimum polynomial generating function
    for the first k terms of a sequence. It should be clear that OP(k, n) will accurately 
    generate the terms of the sequence for n <= k, and potentially the first incorrect term
    (FIT) will be OP(k, k+1); in which case we shall call it a bad OP (BOP).

As a basis, if we were only given the first term of sequence, it would be most sensible
    to assume constancy; that is, for n >= 2, OP(1, n) = u_1.

Hence we obtain the following OPs for the cubic sequence:

OP(1, n) = 1                    1, *1*, 1, 1, ...
OP(2, n) = 7*n - 6              1, 8, *15*, ...
OP(3, n) = 6*n**2 - 11*n + 6    1, 8, 27, *58*, ...
OP(4, n) = n**3                 1, 8, 27, 64, 125, ...
Clearly no BOPs exist for k >= 4.

By considering the sum of FITs generated by the BOPs (indicated above),
    we obtain 1 + 15 + 58 = 74.

Consider the following tenth degree polynomial generating function:

un = 1 - n + n**2 - n**3 + n**4 - n**5 + n**6 - n**7 + n**8 - n**9 + n**10

Find the sum of FITs for the BOPs.
"""

import os

from numpy import matrix
from sympy import Symbol, lambdify, degree
from sympy.parsing.sympy_parser import parse_expr

try:
    from .utils import output_answer
except ImportError:
    from utils import output_answer


def OP(k, pts):
    """
    Spits out a lambda for OP(k, n) that matches the given points.
    """
    n = Symbol('n')
    square_matrix = matrix([[pts[j][0]**i for i in range(k)] for j in range(k)])
    sol_matrix = matrix([[pts[j][1]] for j in range(k)])
    coeff_matrix = square_matrix**-1 * sol_matrix
    eq = sum(round(coeff_matrix.item(i), 0) * n**i for i in range(k))
    return lambdify(n, eq)


def solve(eq='1 - n + n**2 - n**3 + n**4 - n**5 + n**6 - n**7 + n**8 - n**9 + n**10'):
    """
    This amounts to solving an (k-1)th degree polynomial with k points.
        That can be accomplished using Cramer's rule.

    For example, lets solve the example for OP(3, n). We are given the points:
    pts = [(1, 1),
           (2, 8),
           (3, 27)]

    We can say that our target expression is OP(3, n) = a*n**2 + bn + c.
        Lets define our matricies such that

    A = [[1, 1, 1],
         [1, 2, 4],
         [1, 3, 9]]
    Note that A is a k * k matrix, where each row represents each x,
        and each column represents a power of x starting with 0.

    B = [[a],
         [b],
         [c]]

    and

    C = [[1],
         [8],
         [27]]

    And we say that
    A * B = C
    B = A**-1 * C
    B = [[6],
         [-11],
         [6]]

    Note that the first 6 corresponds to c, so our expression is
    6*n**2 - 11*n + 6
    """
    eq = parse_expr(eq)
    eq_degree = degree(eq)
    eq = lambdify(eq.free_symbols, eq)
    points = [(i, eq(i)) for i in range(1, eq_degree + 2)]
    return sum(int(OP(k, points)(k + 1)) for k in range(1, eq_degree + 1))


solve.answer = 37076114526


if __name__ == '__main__':
    output_answer(os.path.splitext(__file__)[0], solve)
